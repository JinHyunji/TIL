# 2차원 배열

- 다차원 배열이란?
    - 2차원 이상의 배열을 의미
    - 배열 요소로 또 다른 배열을 가지는 배열
    - 2차원 배열은 배열 요소로 1차원 배열의 참조를 가지는 배열
    - 3차원 배열은 배열 요소로 2차원 배열의 참조를 가지는 배열
- 2차원 배열 선언
    - int[][] iArr → 권장
    - int iArr[][]
    - int[] iArr[]
- 2차원 배열 생성
    - 배열의 이름 = new 배열유형[1차원 배열개수(행)][1차원 배열의 크기(열)];
    - 배열의 이름 = new 배열유형[1차원 배열개수][];
- 2차원 배열 메모리

<br>

# 2차원 배열의 순회

- 행 우선 순회
- 열 우선 순회
- 지그재그 순회 : 행 우선 순회에서 방향만 거꾸로

<br>

# 2차원 배열의 탐색

- 탐색을 위한 델타 배열 만들기 → 경계 조건 생각하고 만들기

<br>

## 2차원 배열 사방탐색
```Java
public class Array01_2차원배열_사방탐색 {
	public static void main(String[] args) {

		// 다음 배열에서 1이 들어있는 칸의 상하좌우에 인접한 칸에
		// 2를 채워 넣으시오.

		int[][] arr = { { 0, 0, 0, 0, 0 }, { 0, 1, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0 }, { 0, 0, 0, 0, 0 } };

		int N = 5;

		// 델타 배열 만들기
		int[] dr = { -1, 1, 0, 0 };
		int[] dc = { 0, 0, -1, 1 };

		// 1. 행 우선 순회
		for (int r = 0; r < N; r++) {
			for (int c = 0; c < N; c++) {
				if (arr[r][c] == 1) { // 1인 원소를 발견했다면,
					// (r, c) => 1인 원소의 좌표, 기준점!
					// (r, c)를 기준으로 해서 상하좌우의 인접 좌표를 만든다.

					for (int i = 0; i < 4; i++) {
						// 새로운 좌표
						int nr = r + dr[i];
						int nc = c + dc[i];
						arr[nr][nc] = 2;
					}
				}
			}
		}
		// 문제점 => 경계 조건을 고려하지 않음
		
		

		// 2. 출력하기
		for (int r = 0; r < N; r++) {
			for (int c = 0; c < N; c++) {
				System.out.printf("%2d", arr[r][c]);
			}
			System.out.println();
		}

	}
}
```

<br>

## 2차원 배열 사방탐색 - 경계조건

```Java
public class Array02_2차원배열_사방탐색_경계조건 {
    public static void main(String[] args) {
        
        // 다음 배열에서 1이 들어있는 칸의 상하좌우에 인접한 칸에
        // 2를 채워 넣으시오.
        
        int[][] arr = {
                {0, 0, 0, 1, 0},
                {0, 1, 0, 0, 0},
                {0, 0, 0, 0, 1},
                {1, 0, 0, 1, 0},
                {0, 0, 1, 0, 0}
        };
        
        int N = 5;
        
        // 델티 배열 만들기
		int[] dr = { -1, 1, 0, 0 };
		int[] dc = { 0, 0, -1, 1 };
	
		// 1. 행 우선 순회
		for (int r = 0; r < N; r++) {
			for (int c = 0; c < N; c++) {
				if (arr[r][c] == 1) { // 1인 원소를 발견했다면,
					// (r, c) => 1인 원소의 좌표, 기준점!
					// (r, c)를 기준으로 해서 상하좌우의 인접 좌표를 만든다.
	
					for (int i = 0; i < 4; i++) {
						// 새로운 좌표
						int nr = r + dr[i];
						int nc = c + dc[i];
						if (nr >= 0 && nr < N && nc >= 0 && nc <N) {
			     			arr[nr][nc] =2;
			     		}
					}
				}
			}
		}
		// 문제점 => 경계 조건을 고려하지 않음
		// 행렬의 범위를 벗어나는 좌표가 만들어 질 수도 있다.
		// 새로운 좌표가 행렬의 index 범위 안에 있다면 .. => 경계 조건
		
		
	
		// 2. 출력하기
		for (int r = 0; r < N; r++) {
			for (int c = 0; c < N; c++) {
				System.out.printf("%2d", arr[r][c]);
			}
			System.out.println();
		}
    }
}
```

<br>

## 2차원 배열 사방탐색 - 탐색길이
```Java

public class Array03_2차원배열_사방탐색_탐색길이 {
	public static void main(String[] args) {

		// 다음 배열에서 1이 들어있는 칸의 상하좌우 방향으로
		// 길이가 2인 막대를 이어 붙인다. (막대는 2를 채워넣어 표현한다.)

		int[][] arr = { { 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0 },
				{ 0, 0, 0, 1, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0 } };

		int N = 7;

		// 델타 배열 만들기
		int[] dr = { -1, 1, 0, 0 };
		int[] dc = { 0, 0, -1, 1 };

		// 1. 행 우선 순회
		for (int r = 0; r < N; r++) {
			for (int c = 0; c < N; c++) {
				if (arr[r][c] == 1) { // 1인 원소를 발견했다면,
					// (r, c) => 1인 원소의 좌표, 기준점!
					// (r, c)를 기준으로 해서 상하좌우의 인접 좌표를 만든다.

					for (int i = 0; i < 4; i++) {
						// 새로운 좌표
						// 길이도 고려해줘야 한다.
						// => 그 길이만큼 반복
						for (int l = 1; l <= 2; l++) {

							int nr = r + l * dr[i];
							int nc = c + l * dc[i];

							// 문제점 => 경계 조건을 고려하지 않음
							// 행렬의 범위를 벗어나는 좌표가 만들어 질 수도 있다.
							// 새로운 좌표가 행렬의 index 범위 안에 있다면 .. => 경계 조건
							if (nr >= 0 && nr < N && nc >= 0 && nc < N) {
								arr[nr][nc] = 2;
							}
						}
					}
				}
			}
		}

		// 2. 출력하기
		for (int r = 0; r < N; r++) {
			for (int c = 0; c < N; c++) {
				System.out.printf("%2d", arr[r][c]);
			}
			System.out.println();
		}

	}
}
```


<br>

## 2차원 배열 사방탐색 - 탐색 끝까지
```Java

public class Array03_2차원배열_사방탐색_탐색끝까지 {
	public static void main(String[] args) {

		// 다음 배열에서 1이 들어있는 칸을 포함한 행과 열에
		// 모두 2를 채워 넣는다.(1이 들어있는 칸 제외)

		int[][] arr = { 
				{ 0, 0, 0, 0, 0, 0, 0 }, 
				{ 0, 0, 0, 0, 0, 0, 0 }, 
				{ 0, 0, 0, 0, 0, 0, 0 },
				{ 0, 0, 0, 1, 0, 0, 0 }, 
				{ 0, 0, 0, 0, 0, 0, 0 }, 
				{ 0, 0, 0, 0, 0, 0, 0 }, 
				{ 0, 0, 0, 0, 0, 0, 0 }
				};

		int N = 7;

		// 탐색 길이 -> 반복 횟수 -> for문
		// 탐색 끝까지 -> 조건 (반복 횟수 모름) -> while문

		// 델타 배열 만들기
		int[] dr = { -1, 1, 0, 0 };
		int[] dc = { 0, 0, -1, 1 };

		// 1. 행 우선 순회
		for (int r = 0; r < N; r++) {
			for (int c = 0; c < N; c++) {
				if (arr[r][c] == 1) { // 1인 원소를 발견했다면,
					// (r, c) => 1인 원소의 좌표, 기준점!
					// (r, c)를 기준으로 해서 상하좌우의 인접 좌표를 만든다.

					for (int i = 0; i < 4; i++) {
						// 끝까지 가는 경우
						// while문

						// 먼저 해당 방향으로 첫 번째 인접 원소를 만들고
						int nr = r + dr[i];
						int nc = c + dc[i];

						while (nr >= 0 && nr < N && nc >= 0 && nc < N) { // 경계를 벗어나지 않았다면
							arr[nr][nc] = 2; // 2를 채우고
							nr += dr[i]; // 그 방향으로 한 번 더 간다
							nc += dc[i];
						}
					}
				}
			}
		}

		// 2. 출력하기
		for (int r = 0; r < N; r++) {
			for (int c = 0; c < N; c++) {
				System.out.printf("%2d", arr[r][c]);
			}
			System.out.println();
		}

	}
}
```