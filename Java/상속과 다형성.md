# 상속

- 어떤 클래스의 특성을 그대로 갖는 새로운 클래스를 정의한 것
    - 상위 클래스, 부모 클래스(조상), super class
    - 하위 클래스, 자식 클래스(자손), sub class
1. 확장성, 재사용성
    1. 부모의 생성자와 초기화 블록은 상속 X
2. 클래스 선언 시 extends 키워드를 명시
    1. 자바는 다중 상속 허용 안함, 단일 상속 지원
3. 관계
    1. 부모 클래스 : Person
    2. 자식 클래스 : Student
4. 자식 클래스는 부모 클래스의 멤버변수, 메소드를 자신의 것처럼 사용할 수 있다.
    1. 단, 접근 제한자에 따라 사용 여부가 달라진다. (private, default)
5. Object 클래스는 모든 클래스의 조상 클래스
    1. 별도의 extends 선언이 없는 클래스는 extends Object가 생략
6. super 키워드
    1. super를 통해 조상 클래스의 생성자 호출
    2. super()는 첫줄에 와야 함
    3. this() 혹은 super() 하나만 써줘야 함
    4. 부모클래스의 생성자가 먼저 생성됨
7. 오버라이딩(재정의, overriding)
    1. 상속 관계에 있을 때 부모 클래스의 특정 메소드를 바꾸고 싶을 때
    2. 어노테이션 : 컴파일러 주석 → 웬만하면 써주기 (@override)
    3. 상위 클래스에 선언된 메서드를 자식 클래스에서 재정의 하는 것
    4. 메서드의 이름, 반환형, 매개변수 (타입, 개수, 순서) 동일해야 한다.
    5. 하위 클래스의 접근 제어자 범위가 상위 클래스보다 크거나 같아야 한다. (부모 클래스 메서드 : public → 자식 클래스 메서드 : private (X))
    6. 조상보다 더 큰 예외를 던질 수 없다. (부모 실수 조금 → 자식 실수 크게 안됨)
    7. 메서드 오버로딩과 혼동하지 말 것!
    
<br>

# Object

- Object 클래스
    - 가장 최상위 클래스로 모든 클래스의 조상
    - Object의 멤버는 모든 클래스의 멤버 ( toString(), equals(), hashCode(), getClass(), … )
- toString 메서드
    - 객체를 문자열로 변경하는 메서드
    - 정작 궁금한 내용은 주소 값이 아닌 내용이 궁금
- equals() 메서드
    - 두 객체가 같은지를 비교하는 메서드 ( == → 참조형, 주소비교 / String은 equals()로 비교해야 함, 재정의가 되어 있음)
    - 두 개의 레퍼런스 변수가 같은 객체를 가리키고 있는가?
    - 우리가 비교할 것은 정말 객체의 주소 값인가??
        - 두 객체의 내용을 비교할 수 있도록 equals 메서드 재정의
        - 객체의 주소 비교 : == 활용
        - 객체의 내용 비교 : equals 재정의
- hashCode
    - 객체의 해시 코드 : 시스템에서 객체를 구별하기 위해 사용되는 정수값
    - HashSet, HashMap 등에서 객체의 동일성을 확인하기 위해 사용
    - equals 메서드를 재정의 할 때는 반드시 hashCode도 재정의 할 것
    - 미리 작성된 String이나 Number 등에서 재정의 된 hashCode 활용 권장
    
<br>

# final

- final
    - 해당 선언이 최종 상태, 결코 수정될 수 없음
    - final 클래스 : 상속 금지
    - final 메소드 : overriding 금지
    - final 변수 : 더 이상 값을 바꿀 수 없음 상수화
        
<br>


# 다형성

- 상속관계에 있을 때 조상 클래스의 타입으로 자식 클래스 객체를 참조할 수 있다. (반대는 안됨)
- 조상클래스의 타입으로 참조하더라도 자식 객체가 오버라이드한 메서드가 실행됨 → 실제 객체가 중요
- 참조 변수의 형 변환
    - 자손타입 → 조상타입 (묵시적 형 변환) : 형 변환 생략 가능
        
        ```java
        Student st = new Student();
        Person p = st;
        ```
        
    - 조상타입 → 자손타입 (명시적 형 변환) : 형 변환 생략 불가능, 오류가 발생하면 책임
        
        ```java
        Person p = new Person();
        Student st = (Student) p; // 형 변환 연산자 사용
        p.study() // 에러.
        ```
        
- instanceof 연산자
- 참조 변수와 인스턴스 멤버의 관계
    - 자식에서 똑같은 이름으로 멤버 변수를 만듦 → 오버라이드 아님 / 하이딩
    - 하이딩된 멤버 변수는 부모클래스의 타입으로 참조하면 부모의 멤버 변수가 나옴
- 다형성의 활용
    - 다른 타입의 객체를 다루는 배열
    - 매개변수의 다형성