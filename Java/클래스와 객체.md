# 객체 지향 프로그래밍

- 객체 지향 프로그래밍 (OOP)
    1. 객체 단위로 나누어서 (조직화)
    2. 객체 간의 상호작용으로 SW를 설계 및 구현
    - 객체 : 사물과 같이 유형적인 것과 개념이나 논리와 같은 무형적인 것들 → 데이터와 알고리즘(로직)의 묶음
    - 지향 : 작정하거나 지정한 방향으로 나아감
    - 객체 모델링 : 현실 세계의 객체를 SW 객체로 설계하는 것
- 클래스 (Class)
    - 객체를 만드는 설계도
- 인스턴스 (Instance)
    - 클래스를 통해 생성된 객체
    
- 객체 지향 프로그래밍 특징 (A PIE)
    - 추상화 (Abstraction) : 현실 객체 → SW 객체
    - 다형성 (Polymorphism) : 하나의 객체를 다양한 형으로 참조(관점)
    - 상속 (Inheritance) : 기존 클래스 재활용 → 새로운 클래스
    - 캡슐화 (Encapsulation)
        1. 데이터 / 로직
        2. 객체의 속성과 행위 : 공개된 것과 공개되지 않은 것이 있음 → 정보 보호, 굳이 알 필요 없는 부분
- 객체 지향 프로그래밍 장점
    - 모듈화된 프로그래밍 : 수정이 쉽다
    - 재사용성이 높다
    - 디버깅이 용이 → 교체만 하면 됨
    - 정보 보호
    - 협업이 쉽다 (대형 프로젝트)

<br>

# 클래스

- 관련 있는 변수와 함수를 묶어서 만든 사용자 정의 자료형
- 모든 객체들의 생산처
- 클래스 == 객체를 생성하는 틀
- 프로그래밍이 쓰이는 목적을 생각하여 어떤 객체를 만들어야 하는지 결정한다.
- 각 객체들이 어떤 특징(속성과 동작)을 가지고 있을지 결정한다.
- 클래스를 통해 생성된 객체를 인스턴스라고 한다.
- 객체들 사이에서 메시지를 주고 받도록 만들어 준다.

<br>

# 클래스 구성

- 속성 : 필드 (멤버변수)
- 동작 : 메소드 (멤버메서드)
- 생성자
- 중첩 클래스 (클래스 내부의 클래스)

<br>

# 클래스 선언 및 객체의 생성

```code
[접근제한자(public / default)] [활용제한자(final / abstract)] class 클래스명 {

속성 정의 (필드)

기능 정의 (메소드)

생성자

}
```

- 클래스명 변수명 = new 클래스명();
- 변수명.필드명;
- 변수명.메서드명(매개변수);

<br>

# 변수

- 클래스 변수 : 설계도에 들어있는 변수
    - 클래스 영역 선언 (static 키워드) : 메서드 영역
    - 생성시기 : 클래스가 메모리에 올라갔을 때
    - 모든 인스턴스가 공유함
- 인스턴스 변수 : 실제로 만들어진 객체 안에 있는 변수
    - 힙 영역 선언
    - 생성시기 : 인스턴스가 생성되었을 때 (new)
    - 인스턴스 별로 생성됨
- 지역 변수
    - 클래스 영역 이외
    - 생성시기 : 선언되었을 때

<br>

# 메소드 (Method)

- 객체가 할 수 있는 행동을 정의
- 어떤 작업을 수행하는 명령문의 집합에 이름을 붙여 놓은 것
- 메소드의 이름은 소문자로 시작하는 것이 관례

```code
[접근제한자] [활용제한자] 반환값 메소드이름([매개변수들]) {

행위 기술 …

}


public static void main(String[] args) {}
```

- 메소드 선언
    - 선언 시 {} 안에 메소드가 해야 할 일을 정의
- 메소드 호출
    - 객체를 생성한 후 객체의 멤버 메서드를 호출한다
    - 클래스 객체.메소드 이름으로 호출
        
        Person p = new Person();
        
        p.info();
        
    - static이 메소드에 선언되어 있을 때는 클래스이름.메소드이름으로 호출
        
        Person.hello();
        
- 매개변수
    - 메소드에서 사용하는 것
- 인자
    - 호출하는 쪽에서 전달하는 것
- 매개변수 생략 가능
- 파라미터 전달 시 묵시적 형 변환

- 리턴 타입은 메소드를 선언할 때 지정, 없다면 void (return문 생략 가능)
- 리턴 타입을 작성했다면 반드시 해당 타입의 값을 리턴
- 리턴 타입은 하나만 적용 가능

- 메소드 오버로딩
    - 이름이 같고 매개변수가 다른 메소드를 여러 개 정의하는 것
    - 중복 코드에 대한 효율적 관리 가능
    - 파라미터 개수 또는 순서, 타입이 달라야 할 것 (파라미터 이름만 다른 것은 X)
    - 리턴 타입이 다른 것은 의미 X
    

<br>

# 생성자

- 생성자
    - new 키워드와 함께 호출하여 객체 생성
    - 클래스명과 동일
    - 결과형 리턴값을 갖지 않음
    - 객체가 생성될 때 반드시 하나의 생성자 호출
    - 멤버필드의 초기화에 주로 사용
    - 하나의 클래스 내부에 생성자가 하나도 없으면 자동적으로 default 생성자가 있는 것으로 인지
        - default 생성자 : 매개 변수도 없고 내용도 없는 생성자
    - 매개변수의 개수가 다르거나, 자료형이 다른 여러 개의 생성자가 있을 수 있음 (생성자 오버로딩)
    - 생성자의 첫 번째 라인으로 this() 생성자를 사용하여 또 다른 생성자를 하나 호출 가능

<br>

# 생성자 특징

- 클래스 명과 이름이 동일
- 반환타입이 없다
- 기본 생성자
    - 클래스 내에 생성자가 하나도 정의되어 있지 않을 경우 JVM이 자동으로 제공하는 생성자
    - 형태 : 매개변수가 없는 형태, 클래스명() {}
    - 만약 우리가 생성자를 하나라도 만들면 기본 생성자는 자동으로 생성되지 않음
- 파라미터가 있는 생성자
    - 생성자의 목적이 필드 초기화
    - 생성자 호출 시 값을 넘겨주어야 함
    - 해당 생성자를 작성하면 JVM에서 기본 생성자를 추가하지 않음
- 생성자 오버로딩을 지원한다.
- this
    - 참조 변수로써 객체 자신을 가리킴
    - this() 첫 줄에 사용 시 다른 생성자 호출
    - 지역변수와 이름이 동일할 경우 구분하기 위해서 사용
- this의 활용
    - this.멤버변수
    - this 생성자 호출 시 제한 사항
        - 생성자 내에서만 호출 가능
        - 첫 번째 구문에 위치해야 함